# 전체 데이터베이스 마이그레이션 가이드

## 목차

1. [개요](#개요)
2. [데이터베이스 스키마 구조](#데이터베이스-스키마-구조)
3. [테이블 상세 정보](#테이블-상세-정보)
4. [마이그레이션 실행 방법](#마이그레이션-실행-방법)
5. [마이그레이션 관리](#마이그레이션-관리)
6. [문제 해결](#문제-해결)
7. [롤백 방법](#롤백-방법)

## 개요

Analyst Awards System은 PostgreSQL 데이터베이스를 사용하며, Alembic을 통해 마이그레이션을 관리합니다.

### 시스템 요구사항

- PostgreSQL 14 이상
- Python 3.9 이상
- Alembic (Python 패키지)

### 최신 변경사항 (2025-01)

- **BackgroundTasks 도입**: Celery/Redis 의존성 제거 (선택사항)
- **Enum 정의**: 상태 관리를 위한 Enum 클래스 추가 (`apps/api/app/models/enums.py`)
- **외부 API 통합**: OpenDART API, KRX API 추가
- **PDF 일괄 업로드**: 스크립트 추가 (`apps/api/scripts/batch_upload_pdfs.py`)
- **테스트 추가**: 유닛 테스트 및 통합 테스트 추가
- **정합성 점검 및 보완**: 자료수집 및 KPI 평가 기능 개선
- **평가/리포트 관리 페이지 계층 구조**: 기간>애널리스트>리포트 형태로 구현
- **스코어카드 자동 생성**: 평가 완료 시 자동 생성
- **실제 데이터 기반 KPI 계산**: SNS 주목도 및 미디어 언급 빈도 실제 데이터 기반 계산
- **기업명 자동 추출**: 리포트 파싱 시 PDF에서 기업명 자동 추출 및 Company 레코드 생성
- **예측 정보 자동 추출**: 리포트 파싱 시 목표주가, 실적 예측 정보 자동 추출
- **자동 데이터 수집 연동**: 리포트 파싱 완료 후 자동으로 기업 관련 자료 수집 시작
- **Company ticker nullable**: 자동 추출 기능 지원을 위해 ticker 필드를 nullable로 변경

### 데이터베이스 구조

총 **18개 테이블**로 구성되어 있습니다:

1. **기본 엔티티**: analysts, companies, markets
2. **리포트 관련**: reports, report_sections, extracted_texts, extracted_tables, extracted_images
3. **예측 및 결과**: predictions, actual_results
4. **평가 관련**: evaluations, evaluation_scores, evaluation_reports
5. **스코어카드 및 수상**: scorecards, awards
6. **데이터 수집**: data_sources, data_collection_logs, collection_jobs
7. **템플릿**: prompt_templates

## 데이터베이스 스키마 구조

### ERD 관계도

```
analysts (1) ──< (N) reports
analysts (1) ──< (N) evaluations
analysts (1) ──< (N) scorecards
analysts (1) ──< (N) awards
analysts (1) ──< (N) data_collection_logs
analysts (1) ──< (N) collection_jobs

companies (1) ──< (N) reports
companies (1) ──< (N) predictions
companies (1) ──< (N) actual_results
companies (1) ──< (N) evaluations
companies (1) ──< (N) scorecards
companies (1) ──< (N) data_collection_logs

markets (1) ──< (N) reports
markets (1) ──< (N) predictions
markets (1) ──< (N) scorecards

reports (1) ──< (N) report_sections
reports (1) ──< (N) extracted_texts
reports (1) ──< (N) extracted_tables
reports (1) ──< (N) extracted_images
reports (1) ──< (N) predictions
reports (1) ──< (1) evaluations

predictions (1) ──< (N) actual_results

evaluations (1) ──< (N) evaluation_scores
evaluations (1) ──< (1) evaluation_reports

scorecards (1) ──< (N) awards

collection_jobs (1) ──< (N) data_collection_logs
```

## 테이블 상세 정보

### 1. 기본 엔티티 테이블

#### analysts (애널리스트)

```sql
CREATE TABLE analysts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    firm VARCHAR(255) NOT NULL,
    department VARCHAR(255),
    sector VARCHAR(100),
    experience_years INTEGER,
    email VARCHAR(255),
    profile_url TEXT,
    bio TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_analysts_name ON analysts(name);
```

**주요 필드**:
- `name`: 애널리스트 이름
- `firm`: 증권사명
- `department`: 부서
- `sector`: 전문 섹터 (반도체, 자동차, 방산, 금융 등)

#### companies (기업)

```sql
CREATE TABLE companies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ticker VARCHAR(20) UNIQUE NOT NULL,
    name_kr VARCHAR(255) NOT NULL,
    name_en VARCHAR(255),
    sector VARCHAR(100),
    market_cap NUMERIC(20, 2),
    fundamentals JSONB,
    extra_data JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_companies_ticker ON companies(ticker);
```

**주요 필드**:
- `ticker`: 종목 코드 (고유)
- `name_kr`: 한국어 회사명
- `name_en`: 영어 회사명
- `market_cap`: 시가총액
- `fundamentals`: 재무 정보 (JSONB)

#### markets (시장)

```sql
CREATE TABLE markets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    region VARCHAR(100),
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```

**주요 필드**:
- `name`: 시장명 (고유)
- `region`: 지역 (한국, 미국 등)

### 2. 리포트 관련 테이블

#### reports (리포트)

```sql
CREATE TABLE reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    analyst_id UUID NOT NULL REFERENCES analysts(id),
    company_id UUID REFERENCES companies(id),
    market_id UUID REFERENCES markets(id),
    title VARCHAR(500) NOT NULL,
    report_type VARCHAR(50),
    publication_date DATE NOT NULL,
    source_url TEXT,
    file_path TEXT,
    file_size INTEGER,
    status VARCHAR(20) DEFAULT 'pending',
    parsed_json JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_reports_analyst_id ON reports(analyst_id);
CREATE INDEX idx_reports_publication_date ON reports(publication_date);
CREATE INDEX idx_reports_status ON reports(status);
```

**주요 필드**:
- `report_type`: 리포트 유형 (주식, 산업, 이슈전략 등)
- `status`: 처리 상태 (pending, processing, completed, failed)
- `parsed_json`: 파싱된 JSON 데이터

#### report_sections (리포트 섹션)

```sql
CREATE TABLE report_sections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    report_id UUID NOT NULL REFERENCES reports(id) ON DELETE CASCADE,
    section_type VARCHAR(50),
    title VARCHAR(500),
    content TEXT,
    page_number INTEGER,
    order INTEGER,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_report_sections_report_id ON report_sections(report_id);
```

#### extracted_texts (추출된 텍스트)

```sql
CREATE TABLE extracted_texts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    report_id UUID NOT NULL REFERENCES reports(id),
    page_number INTEGER NOT NULL,
    content TEXT NOT NULL,
    bbox JSONB,
    confidence VARCHAR(10),
    language VARCHAR(10),
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_extracted_texts_report_id ON extracted_texts(report_id);
```

#### extracted_tables (추출된 표)

```sql
CREATE TABLE extracted_tables (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    report_id UUID NOT NULL REFERENCES reports(id),
    page_number INTEGER NOT NULL,
    table_data JSONB NOT NULL,
    bbox JSONB,
    confidence VARCHAR(10),
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_extracted_tables_report_id ON extracted_tables(report_id);
```

#### extracted_images (추출된 이미지)

```sql
CREATE TABLE extracted_images (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    report_id UUID NOT NULL REFERENCES reports(id),
    page_number INTEGER NOT NULL,
    image_path TEXT NOT NULL,
    image_type VARCHAR(50),
    bbox JSONB,
    analysis_result JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_extracted_images_report_id ON extracted_images(report_id);
```

### 3. 예측 및 결과 테이블

#### predictions (예측)

```sql
CREATE TABLE predictions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    report_id UUID NOT NULL REFERENCES reports(id),
    company_id UUID REFERENCES companies(id),
    market_id UUID REFERENCES markets(id),
    prediction_type VARCHAR(50) NOT NULL,
    predicted_value NUMERIC(20, 2) NOT NULL,
    unit VARCHAR(20),
    period VARCHAR(20),
    reasoning TEXT,
    confidence VARCHAR(10),
    extra_data JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_predictions_report_id ON predictions(report_id);
CREATE INDEX idx_predictions_prediction_type ON predictions(prediction_type);
```

**주요 필드**:
- `prediction_type`: 예측 유형 (target_price, revenue, operating_profit 등)
- `predicted_value`: 예측값
- `period`: 기간 (2025Q1, 2025-06 등)

#### actual_results (실제 결과)

```sql
CREATE TABLE actual_results (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    prediction_id UUID NOT NULL REFERENCES predictions(id),
    company_id UUID NOT NULL REFERENCES companies(id),
    actual_value NUMERIC(20, 2) NOT NULL,
    unit VARCHAR(20),
    period VARCHAR(20) NOT NULL,
    announcement_date DATE,
    source VARCHAR(255),
    source_url TEXT,
    extra_data JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_actual_results_prediction_id ON actual_results(prediction_id);
CREATE INDEX idx_actual_results_company_id ON actual_results(company_id);
CREATE INDEX idx_actual_results_period ON actual_results(period);
```

### 4. 평가 관련 테이블

#### evaluations (평가)

```sql
CREATE TABLE evaluations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    analyst_id UUID NOT NULL REFERENCES analysts(id),
    company_id UUID REFERENCES companies(id),
    report_id UUID REFERENCES reports(id),
    evaluation_period VARCHAR(20) NOT NULL,
    evaluation_date DATE NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    final_score NUMERIC(10, 2),
    ai_quantitative_score NUMERIC(10, 2),
    sns_market_score NUMERIC(10, 2),
    expert_survey_score NUMERIC(10, 2),
    extra_data JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_evaluations_analyst_id ON evaluations(analyst_id);
CREATE INDEX idx_evaluations_evaluation_period ON evaluations(evaluation_period);
CREATE INDEX idx_evaluations_status ON evaluations(status);
```

**주요 필드**:
- `evaluation_period`: 평가 기간 (2025-Q1)
- `final_score`: 최종 점수
- `ai_quantitative_score`: AI 정량 분석 점수
- `sns_market_score`: SNS·시장 반응 점수
- `expert_survey_score`: 전문가 평가 및 설문 점수

#### evaluation_scores (평가 점수)

```sql
CREATE TABLE evaluation_scores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    evaluation_id UUID NOT NULL REFERENCES evaluations(id) ON DELETE CASCADE,
    score_type VARCHAR(50) NOT NULL,
    score_value NUMERIC(10, 2) NOT NULL,
    weight NUMERIC(5, 4),
    details JSONB,
    reasoning TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_evaluation_scores_evaluation_id ON evaluation_scores(evaluation_id);
CREATE INDEX idx_evaluation_scores_score_type ON evaluation_scores(score_type);
```

**주요 필드**:
- `score_type`: 점수 유형 (target_price_accuracy, performance_accuracy 등)
- `score_value`: 점수 값
- `weight`: 가중치

#### evaluation_reports (평가 보고서)

```sql
CREATE TABLE evaluation_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    evaluation_id UUID UNIQUE NOT NULL REFERENCES evaluations(id),
    analyst_id UUID NOT NULL REFERENCES analysts(id),
    company_id UUID REFERENCES companies(id),
    report_type VARCHAR(50) DEFAULT 'detailed_evaluation',
    report_structure JSONB,
    report_content JSONB,
    report_summary TEXT,
    data_sources_count INTEGER DEFAULT 0,
    verification_status VARCHAR(20) DEFAULT 'pending',
    report_quality_score NUMERIC(5, 4),
    generated_by JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_evaluation_reports_evaluation_id ON evaluation_reports(evaluation_id);
CREATE INDEX idx_evaluation_reports_analyst_id ON evaluation_reports(analyst_id);
```

### 5. 스코어카드 및 수상 테이블

#### scorecards (스코어카드)

```sql
CREATE TABLE scorecards (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    analyst_id UUID NOT NULL REFERENCES analysts(id),
    company_id UUID REFERENCES companies(id),
    market_id UUID REFERENCES markets(id),
    period VARCHAR(20) NOT NULL,
    final_score NUMERIC(10, 2) NOT NULL,
    ranking INTEGER,
    scorecard_data JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_scorecards_analyst_id ON scorecards(analyst_id);
CREATE INDEX idx_scorecards_period ON scorecards(period);
CREATE INDEX idx_scorecards_final_score ON scorecards(final_score);
CREATE INDEX idx_scorecards_ranking ON scorecards(ranking);
```

#### awards (수상 내역)

```sql
CREATE TABLE awards (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    scorecard_id UUID NOT NULL REFERENCES scorecards(id),
    analyst_id UUID NOT NULL REFERENCES analysts(id),
    award_type VARCHAR(20) NOT NULL,
    award_category VARCHAR(50) NOT NULL,
    period VARCHAR(20) NOT NULL,
    rank INTEGER NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_awards_scorecard_id ON awards(scorecard_id);
CREATE INDEX idx_awards_analyst_id ON awards(analyst_id);
CREATE INDEX idx_awards_award_category ON awards(award_category);
CREATE INDEX idx_awards_period ON awards(period);
CREATE INDEX idx_awards_rank ON awards(rank);
```

**주요 필드**:
- `award_type`: 수상 유형 (gold, silver, bronze)
- `award_category`: 수상 카테고리 (AI, 2차전지, 방산, IPO 등)

### 6. 데이터 수집 테이블

#### data_sources (데이터 소스)

```sql
CREATE TABLE data_sources (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    source_name VARCHAR(255) UNIQUE NOT NULL,
    source_type VARCHAR(50) NOT NULL,
    source_url VARCHAR(500),
    reliability VARCHAR(20),
    update_frequency VARCHAR(50),
    last_updated TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    extra_data JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_data_sources_source_type ON data_sources(source_type);
CREATE INDEX idx_data_sources_is_active ON data_sources(is_active);
```

**주요 필드**:
- `source_type`: 소스 유형 (dart, news, sns 등)
- `reliability`: 신뢰도 (high, medium, low)
- `update_frequency`: 업데이트 빈도 (daily, weekly, monthly)

#### collection_jobs (수집 작업)

```sql
CREATE TABLE collection_jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    analyst_id UUID NOT NULL REFERENCES analysts(id),
    collection_types TEXT[] NOT NULL,
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    progress JSONB DEFAULT '{}',
    overall_progress VARCHAR(10) DEFAULT '0.0',
    estimated_completion_time TIMESTAMP WITH TIME ZONE,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    error_message VARCHAR(500),
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_collection_jobs_analyst_id ON collection_jobs(analyst_id);
CREATE INDEX idx_collection_jobs_status ON collection_jobs(status);
```

**주요 필드**:
- `collection_types`: 수집 유형 배열 (["target_price", "performance", "sns", "media"])
- `status`: 작업 상태 (pending, running, completed, failed)
- `progress`: 진행 상황 (JSONB)

#### data_collection_logs (데이터 수집 이력)

```sql
CREATE TABLE data_collection_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    analyst_id UUID NOT NULL REFERENCES analysts(id),
    company_id UUID REFERENCES companies(id),
    collection_job_id UUID REFERENCES collection_jobs(id),
    collection_type VARCHAR(50) NOT NULL,
    prompt_template_id VARCHAR(100),
    perplexity_request JSONB,
    perplexity_response JSONB,
    collected_data JSONB,
    status VARCHAR(20) NOT NULL,
    error_message TEXT,
    collection_time FLOAT,
    token_usage JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_data_collection_logs_analyst_id ON data_collection_logs(analyst_id);
CREATE INDEX idx_data_collection_logs_collection_type ON data_collection_logs(collection_type);
CREATE INDEX idx_data_collection_logs_status ON data_collection_logs(status);
CREATE INDEX idx_data_collection_logs_collection_job_id ON data_collection_logs(collection_job_id);
```

**주요 필드**:
- `collection_type`: 수집 유형 (target_price, performance, sns, media)
- `status`: 상태 (success, failed, partial)
- `collection_time`: 소요 시간 (초)

### 7. 템플릿 테이블

#### prompt_templates (프롬프트 템플릿)

```sql
CREATE TABLE prompt_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_name VARCHAR(255) UNIQUE NOT NULL,
    template_type VARCHAR(50) NOT NULL,
    kpi_type VARCHAR(50),
    prompt_content TEXT NOT NULL,
    input_schema JSONB,
    output_schema JSONB,
    max_input_tokens INTEGER DEFAULT 1000000,
    max_output_tokens INTEGER DEFAULT 100000,
    version VARCHAR(20) DEFAULT '1.0.0',
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_prompt_templates_template_type ON prompt_templates(template_type);
CREATE INDEX idx_prompt_templates_kpi_type ON prompt_templates(kpi_type);
CREATE INDEX idx_prompt_templates_is_active ON prompt_templates(is_active);
```

**주요 필드**:
- `template_type`: 템플릿 유형 (target_price, performance, sns, media)
- `kpi_type`: KPI 유형
- `prompt_content`: 프롬프트 내용

## 마이그레이션 버전 정보

### 현재 마이그레이션 버전

- **001_initial_migration**: 초기 테이블 생성 (17개 테이블) ✅ **구현 완료**
- **002_add_collection_job**: collection_jobs 테이블 추가 ✅ **구현 완료**
- **003 (478d6db4f74b)**: Company 모델의 ticker 필드를 nullable로 변경 ✅ **구현 완료**
  - **기본 엔티티 (3개)**: analysts, companies, markets
  - **리포트 관련 (5개)**: reports, report_sections, extracted_texts, extracted_tables, extracted_images
  - **예측 및 결과 (2개)**: predictions, actual_results
  - **평가 관련 (3개)**: evaluations, evaluation_scores, evaluation_reports
  - **스코어카드 및 수상 (2개)**: scorecards, awards
  - **데이터 수집 (1개)**: data_sources, data_collection_logs
  - **템플릿 (1개)**: prompt_templates
  
  **구현 내용**:
  - 모든 테이블 생성 (17개)
  - 모든 외래 키 제약 조건 설정
  - 모든 인덱스 생성
  - `upgrade()` 및 `downgrade()` 함수 완전 구현

- **002_add_collection_job**: 데이터 수집 작업 테이블 추가
  - collection_jobs 테이블 생성
  - data_collection_logs에 collection_job_id 컬럼 추가

### 마이그레이션 확인

```bash
cd apps/api
alembic current  # 현재 버전 확인
alembic history  # 전체 히스토리 확인
alembic show head  # 최신 마이그레이션 정보 확인
```

## 마이그레이션 실행 방법

### 사전 준비

#### 1. 데이터베이스 연결 확인

```bash
# PostgreSQL 서비스 상태 확인 (macOS)
brew services list | grep postgresql

# 또는 Docker Compose 사용 시
docker-compose ps
```

#### 2. 환경 변수 설정

`.env` 파일 또는 환경 변수에 `DATABASE_URL` 설정:

```bash
# 로컬 PostgreSQL 사용 시
export DATABASE_URL="postgresql://user:password@localhost:5432/analyst_awards"

# Docker Compose 사용 시
export DATABASE_URL="postgresql://user:password@postgres:5432/analyst_awards"
```

### 방법 1: Docker Compose 사용 (권장)

```bash
# 프로젝트 루트에서
cd "/Users/seungminlee/Downloads/AAA 2"

# Docker Compose로 서비스 시작
docker-compose up -d postgres

# API 컨테이너에서 마이그레이션 실행
docker-compose exec api alembic upgrade head

# 또는 직접 실행
docker-compose run --rm api alembic upgrade head
```

### 방법 2: 로컬에서 직접 실행

```bash
cd apps/api

# 환경 변수 설정
export DATABASE_URL="postgresql://user:password@localhost:5432/analyst_awards"

# 마이그레이션 실행
alembic upgrade head
```

### 방법 3: Alembic Python 스크립트로 실행

```bash
cd apps/api

# 환경 변수 설정
export DATABASE_URL="postgresql://user:password@localhost:5432/analyst_awards"

# Python으로 직접 실행
python -c "
from alembic.config import Config
from alembic import command
import os

alembic_cfg = Config('alembic.ini')
alembic_cfg.set_main_option('sqlalchemy.url', os.getenv('DATABASE_URL'))
command.upgrade(alembic_cfg, 'head')
"
```

### 방법 4: init_db.py 사용 (개발 환경 전용)

**주의**: `init_db.py`는 SQLAlchemy의 `Base.metadata.create_all()`을 사용하므로 Alembic 마이그레이션 히스토리를 생성하지 않습니다. 
Alembic을 사용하는 프로덕션 환경에서는 **방법 1 또는 2를 권장**합니다.

```bash
cd apps/api

# 환경 변수 설정
export DATABASE_URL="postgresql://user:password@localhost:5432/analyst_awards"

# init_db.py 실행
python scripts/init_db.py
```

**init_db.py 사용 시 주의사항**:
- ✅ 모든 모델이 `app/models/__init__.py`에서 export되어 있어야 함
- ✅ `ExtractedText`, `ExtractedTable`, `ExtractedImage` 모델 포함 확인
- ⚠️ Alembic 마이그레이션 히스토리와 무관하게 테이블만 생성
- ⚠️ 프로덕션 환경에서는 Alembic 사용 권장

## 마이그레이션 관리

### 마이그레이션 상태 확인

```bash
cd apps/api

# 현재 마이그레이션 버전 확인
alembic current

# 마이그레이션 히스토리 확인
alembic history

# 특정 버전까지의 변경사항 확인
alembic history --verbose
```

### 새 마이그레이션 생성

모델 변경 후 새 마이그레이션 파일 생성:

```bash
cd apps/api

# 자동 생성 (모델 변경사항 감지)
alembic revision --autogenerate -m "설명"

# 수동 생성
alembic revision -m "설명"
```

### 마이그레이션 적용

```bash
cd apps/api

# 최신 버전까지 업그레이드
alembic upgrade head

# 특정 버전으로 업그레이드
alembic upgrade <revision_id>

# 한 단계만 업그레이드
alembic upgrade +1
```

### 마이그레이션 롤백

```bash
cd apps/api

# 한 단계 롤백
alembic downgrade -1

# 특정 버전으로 롤백
alembic downgrade <revision_id>

# 모든 마이그레이션 롤백
alembic downgrade base
```

### 데이터베이스 스키마 확인

```sql
-- 모든 테이블 목록 확인
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'public' 
ORDER BY table_name;

-- 특정 테이블 구조 확인
SELECT column_name, data_type, is_nullable, column_default
FROM information_schema.columns
WHERE table_name = 'analysts'
ORDER BY ordinal_position;

-- 외래 키 제약 조건 확인
SELECT
    tc.table_name, 
    kcu.column_name, 
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name 
FROM information_schema.table_constraints AS tc 
JOIN information_schema.key_column_usage AS kcu
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
  ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY';

-- 인덱스 확인
SELECT indexname, tablename, indexdef
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY tablename, indexname;
```

## 문제 해결

### 오류: "role 'user' does not exist"

**원인**: PostgreSQL 사용자가 존재하지 않음

**해결 방법**:
```bash
# PostgreSQL에 접속
psql -U postgres

# 사용자 생성
CREATE USER user WITH PASSWORD 'password';
CREATE DATABASE analyst_awards OWNER user;
GRANT ALL PRIVILEGES ON DATABASE analyst_awards TO user;
```

### 오류: "connection refused"

**원인**: PostgreSQL 서비스가 실행되지 않음

**해결 방법**:
```bash
# macOS (Homebrew)
brew services start postgresql@14

# 또는 Docker Compose
docker-compose up -d postgres
```

### 오류: "database does not exist"

**원인**: 데이터베이스가 생성되지 않음

**해결 방법**:
```bash
# PostgreSQL에 접속
psql -U postgres

# 데이터베이스 생성
CREATE DATABASE analyst_awards;
```

### 오류: "relation already exists"

**원인**: 테이블이 이미 존재함

**해결 방법**:
```bash
# 마이그레이션 상태 확인
alembic current

# 마이그레이션 히스토리 확인
alembic history

# 필요시 특정 버전으로 마킹
alembic stamp <revision_id>
```

### 오류: "Can't locate revision identified by"

**원인**: 마이그레이션 버전 불일치

**해결 방법**:
```bash
# 현재 데이터베이스 상태 확인
alembic current

# 마이그레이션 히스토리 확인
alembic history

# 필요시 특정 버전으로 마킹
alembic stamp head
```

### 마이그레이션 충돌 해결

여러 개발자가 동시에 마이그레이션을 생성한 경우:

```bash
# 1. 최신 마이그레이션 가져오기
git pull

# 2. 현재 마이그레이션 상태 확인
alembic current

# 3. 충돌하는 마이그레이션 파일 확인
# 4. 수동으로 병합하거나 rebase 수행
# 5. 마이그레이션 적용
alembic upgrade head
```

## 롤백 방법

### 마이그레이션 롤백

```bash
cd apps/api

# 한 단계 롤백
alembic downgrade -1

# 특정 버전으로 롤백
alembic downgrade <revision_id>

# 모든 마이그레이션 롤백 (주의!)
alembic downgrade base
```

### 수동 롤백 (SQL)

마이그레이션 롤백이 실패하는 경우 수동으로 SQL 실행:

```sql
-- 예: collection_jobs 테이블 롤백
DROP INDEX IF EXISTS idx_data_collection_logs_collection_job_id;
ALTER TABLE data_collection_logs DROP CONSTRAINT IF EXISTS fk_data_collection_logs_collection_job_id;
ALTER TABLE data_collection_logs DROP COLUMN IF EXISTS collection_job_id;
DROP INDEX IF EXISTS idx_collection_jobs_status;
DROP INDEX IF EXISTS idx_collection_jobs_analyst_id;
DROP TABLE IF EXISTS collection_jobs;
```

**주의**: 수동 롤백은 데이터 손실 위험이 있으므로 백업 후 수행하세요.

## 마이그레이션 체크리스트

마이그레이션 실행 전 확인사항:

- [ ] 데이터베이스 백업 완료
- [ ] 환경 변수 `DATABASE_URL` 설정 확인
- [ ] PostgreSQL 서비스 실행 확인
- [ ] 현재 마이그레이션 버전 확인 (`alembic current`)
- [ ] 마이그레이션 히스토리 확인 (`alembic history`)
- [ ] 테스트 환경에서 먼저 실행
- [ ] 롤백 계획 수립

마이그레이션 실행 후 확인사항:

- [ ] 마이그레이션 버전 확인 (`alembic current`)
- [ ] 테이블 생성 확인
- [ ] 인덱스 생성 확인
- [ ] 외래 키 제약 조건 확인
- [ ] 애플리케이션 정상 동작 확인
- [ ] 데이터 무결성 확인

## 다음 단계

마이그레이션 실행 후:

1. ✅ 마이그레이션 버전 확인 (`alembic current`)
2. ✅ 테이블 생성 확인 (PostgreSQL에서 직접 확인)
3. ✅ API 서버 재시작
4. ✅ Celery 워커 재시작 (있는 경우 - BackgroundTasks 사용 시 불필요)
5. ✅ 통합 테스트 실행 (`pytest tests/`)
6. ✅ 기능 동작 확인
7. ✅ 성능 모니터링
8. ✅ 평가/리포트 관리 페이지 계층 구조 확인
9. ✅ 스코어카드 자동 생성 확인
10. ✅ 자료수집 및 KPI 평가 기능 테스트

## 마이그레이션 구현 상태

### ✅ 001_initial_migration.py 구현 완료

**구현 내용**:
- 17개 테이블 생성 코드 완전 구현
- 모든 외래 키 제약 조건 설정
- 모든 인덱스 생성
- `upgrade()` 함수: 모든 테이블 및 인덱스 생성
- `downgrade()` 함수: 역순으로 모든 테이블 및 인덱스 삭제

**테이블 목록**:
1. analysts
2. companies
3. markets
4. reports
5. report_sections
6. extracted_texts
7. extracted_tables
8. extracted_images
9. predictions
10. actual_results
11. evaluations
12. evaluation_scores
13. evaluation_reports
14. scorecards
15. awards
16. data_sources
17. data_collection_logs
18. prompt_templates

**참고**: `collection_jobs` 테이블은 `002_add_collection_job` 마이그레이션에서 생성됩니다.

### ✅ 모델 Export 수정 완료

**수정 내용**:
- `app/models/__init__.py`에 `ExtractedText`, `ExtractedTable`, `ExtractedImage` 추가
- `init_db.py`에서 모든 모델 import 가능

**Export된 모델 목록**:
- Analyst, Company, Market
- Report, ReportSection, **ExtractedText**, **ExtractedTable**, **ExtractedImage**
- Prediction, ActualResult
- Evaluation, EvaluationScore
- Scorecard, Award
- DataSource, DataCollectionLog, CollectionJob
- EvaluationReport, PromptTemplate

### ✅ init_db.py 사용 가능

**사용 방법**:
```bash
cd apps/api
export DATABASE_URL="postgresql://user:password@localhost:5432/analyst_awards"
python scripts/init_db.py
```

**주의사항**:
- ✅ 모든 모델이 `app/models/__init__.py`에서 export되어 있어야 함
- ✅ `ExtractedText`, `ExtractedTable`, `ExtractedImage` 모델 포함 확인
- ⚠️ Alembic 마이그레이션 히스토리와 무관하게 테이블만 생성
- ⚠️ 프로덕션 환경에서는 Alembic 사용 권장

## 참고 자료

- [Alembic 공식 문서](https://alembic.sqlalchemy.org/)
- [SQLAlchemy 공식 문서](https://docs.sqlalchemy.org/)
- [PostgreSQL 공식 문서](https://www.postgresql.org/docs/)

## 문의 및 지원

마이그레이션 관련 문제가 발생하면:

1. 마이그레이션 로그 확인
2. 데이터베이스 상태 확인
3. 환경 변수 확인
4. 프로젝트 이슈 트래커에 보고

